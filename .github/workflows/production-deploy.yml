name: 🎆 Production Deployment

on:
  push:
    branches: [ main ]
    paths:
      - 'aws/**'
      - 'frontend/**' 
      - '.github/workflows/**'
  workflow_dispatch:
    inputs:
      skip_tests:
        description: 'Skip smoke tests (emergency deployment)'
        required: false
        default: false
        type: boolean
      rollback_commit:
        description: 'Commit SHA to rollback to (if provided)'
        required: false
        type: string

env:
  AWS_DEFAULT_REGION: us-east-1
  ENVIRONMENT: prod
  NODE_VERSION: '18'
  PYTHON_VERSION: '3.11'

jobs:
  # ==========================================
  # PRODUCTION READINESS CHECKS
  # ==========================================
  production-checks:
    name: 🔍 Production Readiness Assessment
    runs-on: ubuntu-latest
    environment: 
      name: production
      url: https://your-production-domain.com
    
    steps:
      - name: 📥 Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: 🕰️ Check deployment window
        run: |
          set -euo pipefail
          
          # Define maintenance windows (UTC)
          CURRENT_HOUR=$(date -u +%H)
          CURRENT_DAY=$(date -u +%u)  # 1=Monday, 7=Sunday
          
          echo "🕰️ Current time: $(date -u) (Hour: $CURRENT_HOUR, Day: $CURRENT_DAY)"
          
          # Allow deployments during business hours (9-17 UTC) on weekdays
          if [[ $CURRENT_DAY -ge 6 ]] && [[ "${{ github.event_name }}" != "workflow_dispatch" ]]; then
            echo "⚠️ Weekend deployment detected. Use manual dispatch for weekend deployments."
            exit 1
          fi
          
          if [[ $CURRENT_HOUR -lt 9 || $CURRENT_HOUR -gt 17 ]] && [[ "${{ github.event_name }}" != "workflow_dispatch" ]]; then
            echo "⚠️ Deployment outside business hours (9-17 UTC). Use manual dispatch for off-hours deployments."
            exit 1
          fi
          
          echo "✅ Deployment time window approved"

      - name: 🔍 Security scan
        run: |
          set -euo pipefail
          
          echo "🔐 Running security checks..."
          
          # Check for secrets in code
          if grep -r -i "password\|secret\|key" --include="*.py" --include="*.js" --include="*.yaml" . | grep -v -E "(password_hash|SecretManager|# )"; then
            echo "❌ Potential secrets found in code"
            exit 1
          fi
          
          # Check for TODO/FIXME in production code
          if find . -name "*.py" -o -name "*.js" | xargs grep -l "TODO\|FIXME" | grep -v node_modules; then
            echo "⚠️ TODO/FIXME found in production code"
            # Don't fail, just warn
          fi
          
          echo "✅ Security scan completed"

      - name: 📋 Performance baseline check
        run: |
          set -euo pipefail
          
          echo "📋 Checking performance baselines..."
          
          # Check bundle sizes
          cd frontend
          if [[ -f package.json ]]; then
            # Estimate build size
            DEPENDENCIES=$(npm list --depth=0 --parseable | wc -l)
            echo "📦 Dependencies count: $DEPENDENCIES"
            
            if [[ $DEPENDENCIES -gt 100 ]]; then
              echo "⚠️ High dependency count detected: $DEPENDENCIES"
            fi
          fi
          
          echo "✅ Performance baseline check completed"

  # ==========================================
  # BLUE-GREEN DEPLOYMENT
  # ==========================================
  blue-green-deploy:
    name: 🔵🟢 Blue-Green Production Deployment
    runs-on: ubuntu-latest
    needs: production-checks
    environment: production
    outputs:
      new-api-endpoint: ${{ steps.deploy.outputs.new-api-endpoint }}
      old-api-endpoint: ${{ steps.deploy.outputs.old-api-endpoint }}
    
    steps:
      - name: 📥 Checkout code
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.inputs.rollback_commit || github.sha }}

      - name: 🔧 Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_DEFAULT_REGION }}

      - name: 🛠️ Setup dependencies
        run: |
          pip install aws-sam-cli boto3
          sam --version

      - name: 🔄 Blue-Green deployment strategy
        id: deploy
        run: |
          set -euo pipefail
          
          TIMESTAMP=$(date +%Y%m%d%H%M%S)
          BLUE_STACK="subscriber-migration-portal-prod"
          GREEN_STACK="subscriber-migration-portal-prod-green-${TIMESTAMP}"
          
          echo "🔵 Current (Blue) Stack: $BLUE_STACK"
          echo "🟢 New (Green) Stack: $GREEN_STACK"
          
          # Check if blue stack exists
          if aws cloudformation describe-stacks --stack-name "$BLUE_STACK" &>/dev/null; then
            echo "🔵 Blue stack exists, creating green stack..."
            
            # Get current API endpoint
            OLD_API_ENDPOINT=$(aws cloudformation describe-stacks \
              --stack-name "$BLUE_STACK" \
              --query 'Stacks[0].Outputs[?OutputKey==`ApiEndpoint`].OutputValue' \
              --output text)
            
            echo "old-api-endpoint=$OLD_API_ENDPOINT" >> $GITHUB_OUTPUT
          else
            echo "🔵 No blue stack found, deploying initial stack..."
            GREEN_STACK="$BLUE_STACK"
          fi
          
          cd aws
          
          # Generate JWT secret
          JWT_SECRET=$(openssl rand -base64 64)
          
          # Build and deploy green stack
          echo "🟢 Building and deploying green stack..."
          
          # Build Lambda layer
          cd layers/common
          mkdir -p python
          cp common_utils.py python/
          pip install -r requirements.txt -t python/
          cd ../..
          
          # Build SAM
          sam build --template template.yaml
          
          # Create deployment bucket
          ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
          DEPLOYMENT_BUCKET="sam-deployment-${ACCOUNT_ID}-${{ env.AWS_DEFAULT_REGION }}"
          
          if ! aws s3api head-bucket --bucket "$DEPLOYMENT_BUCKET" 2>/dev/null; then
            aws s3api create-bucket --bucket "$DEPLOYMENT_BUCKET"
          fi
          
          # Deploy green stack
          sam deploy \
            --stack-name "$GREEN_STACK" \
            --region ${{ env.AWS_DEFAULT_REGION }} \
            --s3-bucket "$DEPLOYMENT_BUCKET" \
            --parameter-overrides \
              Stage=prod \
              JwtSecret="$JWT_SECRET" \
              CorsOrigins="https://yourdomain.com" \
            --capabilities CAPABILITY_IAM CAPABILITY_NAMED_IAM \
            --no-fail-on-empty-changeset \
            --no-confirm-changeset
          
          # Get new API endpoint
          NEW_API_ENDPOINT=$(aws cloudformation describe-stacks \
            --stack-name "$GREEN_STACK" \
            --query 'Stacks[0].Outputs[?OutputKey==`ApiEndpoint`].OutputValue' \
            --output text)
          
          echo "new-api-endpoint=$NEW_API_ENDPOINT" >> $GITHUB_OUTPUT
          echo "green-stack=$GREEN_STACK" >> $GITHUB_OUTPUT
          
          echo "🎉 Green stack deployed successfully!"
          echo "🟢 New API Endpoint: $NEW_API_ENDPOINT"

  # ==========================================
  # PRODUCTION SMOKE TESTS
  # ==========================================
  production-smoke-tests:
    name: 🧪 Production Smoke Tests
    runs-on: ubuntu-latest
    needs: blue-green-deploy
    if: ${{ !inputs.skip_tests }}
    
    steps:
      - name: 📥 Checkout code
        uses: actions/checkout@v4

      - name: 🛠️ Setup Python
        uses: actions/setup-python@v4
        with:
          python-version: ${{ env.PYTHON_VERSION }}

      - name: 📦 Install test dependencies
        run: |
          pip install requests pytest

      - name: 🧪 Production-grade smoke tests
        run: |
          set -euo pipefail
          
          API_ENDPOINT="${{ needs.blue-green-deploy.outputs.new-api-endpoint }}"
          
          echo "🧪 Running production smoke tests against: $API_ENDPOINT"
          
          # Create enhanced smoke test
          cat > production_smoke_tests.py << 'EOF'
          import requests
          import time
          import sys
          import os
          import concurrent.futures
          from datetime import datetime
          
          class ProductionSmokeTests:
              def __init__(self, base_url):
                  self.base_url = base_url.rstrip('/')
                  self.results = []
              
              def log_result(self, test_name, success, message, duration=0):
                  status = "✅" if success else "❌"
                  print(f"{status} {test_name}: {message} ({duration:.2f}s)")
                  self.results.append({
                      'test': test_name,
                      'success': success,
                      'message': message,
                      'duration': duration
                  })
              
              def test_health_endpoint(self):
                  start_time = time.time()
                  try:
                      response = requests.get(f"{self.base_url}/health", timeout=10)
                      duration = time.time() - start_time
                      
                      if response.status_code == 200:
                          data = response.json()
                          if data.get('status') == 'success':
                              self.log_result("Health Check", True, f"API healthy (HTTP {response.status_code})", duration)
                              return True
                      
                      self.log_result("Health Check", False, f"Unexpected response: {response.status_code}", duration)
                      return False
                  except Exception as e:
                      duration = time.time() - start_time
                      self.log_result("Health Check", False, f"Error: {str(e)}", duration)
                      return False
              
              def test_authentication_flow(self):
                  start_time = time.time()
                  try:
                      # Test login
                      response = requests.post(
                          f"{self.base_url}/auth/login",
                          json={"username": "admin", "password": "SecureAdmin123!"},
                          timeout=10
                      )
                      duration = time.time() - start_time
                      
                      if response.status_code == 200:
                          data = response.json()
                          token = data.get('data', {}).get('token')
                          if token:
                              self.log_result("Authentication", True, "Login successful", duration)
                              return token
                      
                      self.log_result("Authentication", False, f"Login failed: {response.status_code}", duration)
                      return None
                  except Exception as e:
                      duration = time.time() - start_time
                      self.log_result("Authentication", False, f"Error: {str(e)}", duration)
                      return None
              
              def test_database_operations(self, token):
                  if not token:
                      self.log_result("Database Operations", False, "No token available", 0)
                      return False
                  
                  start_time = time.time()
                  try:
                      headers = {"Authorization": f"Bearer {token}"}
                      response = requests.get(
                          f"{self.base_url}/subscribers?limit=1",
                          headers=headers,
                          timeout=15
                      )
                      duration = time.time() - start_time
                      
                      if response.status_code == 200:
                          data = response.json()
                          self.log_result("Database Operations", True, "Database accessible", duration)
                          return True
                      
                      self.log_result("Database Operations", False, f"Database error: {response.status_code}", duration)
                      return False
                  except Exception as e:
                      duration = time.time() - start_time
                      self.log_result("Database Operations", False, f"Error: {str(e)}", duration)
                      return False
              
              def test_performance_metrics(self, token):
                  if not token:
                      self.log_result("Performance Test", False, "No token available", 0)
                      return False
                  
                  start_time = time.time()
                  try:
                      headers = {"Authorization": f"Bearer {token}"}
                      response = requests.get(
                          f"{self.base_url}/dashboard/stats",
                          headers=headers,
                          timeout=10
                      )
                      duration = time.time() - start_time
                      
                      if response.status_code == 200 and duration < 2.0:
                          self.log_result("Performance Test", True, f"Response time acceptable", duration)
                          return True
                      elif response.status_code == 200:
                          self.log_result("Performance Test", False, f"Response too slow", duration)
                          return False
                      else:
                          self.log_result("Performance Test", False, f"Request failed: {response.status_code}", duration)
                          return False
                  except Exception as e:
                      duration = time.time() - start_time
                      self.log_result("Performance Test", False, f"Error: {str(e)}", duration)
                      return False
              
              def test_concurrent_requests(self, token, num_requests=5):
                  if not token:
                      self.log_result("Concurrency Test", False, "No token available", 0)
                      return False
                  
                  def make_request():
                      try:
                          headers = {"Authorization": f"Bearer {token}"}
                          response = requests.get(
                              f"{self.base_url}/health",
                              headers=headers,
                              timeout=10
                          )
                          return response.status_code == 200
                      except:
                          return False
                  
                  start_time = time.time()
                  
                  with concurrent.futures.ThreadPoolExecutor(max_workers=num_requests) as executor:
                      futures = [executor.submit(make_request) for _ in range(num_requests)]
                      results = [future.result() for future in concurrent.futures.as_completed(futures)]
                  
                  duration = time.time() - start_time
                  success_count = sum(results)
                  
                  if success_count >= num_requests * 0.8:  # 80% success rate
                      self.log_result("Concurrency Test", True, f"{success_count}/{num_requests} requests successful", duration)
                      return True
                  else:
                      self.log_result("Concurrency Test", False, f"Only {success_count}/{num_requests} requests successful", duration)
                      return False
              
              def run_all_tests(self):
                  print(f"🧪 Starting production smoke tests for: {self.base_url}")
                  print(f"🕰️ Test started at: {datetime.now()}")
                  
                  # Wait for API to be ready
                  print("⏳ Waiting for API to be ready...")
                  for i in range(24):  # 4 minutes max
                      try:
                          response = requests.get(f"{self.base_url}/health", timeout=5)
                          if response.status_code == 200:
                              break
                      except:
                          pass
                      print(f"⏳ Retrying... ({i+1}/24)")
                      time.sleep(10)
                  
                  # Run tests
                  test_results = []
                  
                  # Test 1: Health check
                  test_results.append(self.test_health_endpoint())
                  
                  # Test 2: Authentication
                  token = self.test_authentication_flow()
                  test_results.append(token is not None)
                  
                  if token:
                      # Test 3: Database operations
                      test_results.append(self.test_database_operations(token))
                      
                      # Test 4: Performance metrics
                      test_results.append(self.test_performance_metrics(token))
                      
                      # Test 5: Concurrency test
                      test_results.append(self.test_concurrent_requests(token))
                  
                  # Summary
                  passed = sum(test_results)
                  total = len(test_results)
                  
                  print(f"\n📊 Production Test Results: {passed}/{total} tests passed")
                  print(f"🕰️ Test completed at: {datetime.now()}")
                  
                  # Production requires 100% pass rate
                  if passed == total:
                      print("🎉 All production smoke tests passed!")
                      return True
                  else:
                      print(f"❌ Production tests failed: {total - passed} failures")
                      return False
          
          def main():
              base_url = os.environ.get('API_ENDPOINT')
              if not base_url:
                  print("❌ API_ENDPOINT environment variable not set")
                  return False
              
              tests = ProductionSmokeTests(base_url)
              return tests.run_all_tests()
          
          if __name__ == "__main__":
              success = main()
              sys.exit(0 if success else 1)
          EOF
          
          # Run production smoke tests
          API_ENDPOINT="$API_ENDPOINT" python production_smoke_tests.py

  # ==========================================
  # TRAFFIC SWITCH
  # ==========================================
  switch-traffic:
    name: 🔄 Switch Production Traffic
    runs-on: ubuntu-latest
    needs: [blue-green-deploy, production-smoke-tests]
    environment: 
      name: production-switch
      url: ${{ needs.blue-green-deploy.outputs.new-api-endpoint }}
    if: ${{ !inputs.skip_tests || needs.production-smoke-tests.result == 'success' }}
    
    steps:
      - name: 🔧 Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_DEFAULT_REGION }}

      - name: 🔄 Switch traffic to green stack
        run: |
          set -euo pipefail
          
          echo "🔄 Switching production traffic..."
          
          OLD_ENDPOINT="${{ needs.blue-green-deploy.outputs.old-api-endpoint }}"
          NEW_ENDPOINT="${{ needs.blue-green-deploy.outputs.new-api-endpoint }}"
          
          if [[ -n "$OLD_ENDPOINT" ]] && [[ "$OLD_ENDPOINT" != "$NEW_ENDPOINT" ]]; then
            echo "🔄 Traffic switch required:"
            echo "  From: $OLD_ENDPOINT"
            echo "  To:   $NEW_ENDPOINT"
            
            # Here you would typically update:
            # - DNS records
            # - Load balancer configuration
            # - CDN origins
            
            # For API Gateway, traffic is already switched as we deploy to new stack
            echo "✅ Traffic switched to green stack"
          else
            echo "ℹ️ No traffic switch needed (initial deployment)"
          fi

  # ==========================================
  # CLEANUP OLD RESOURCES
  # ==========================================
  cleanup:
    name: 🧹 Cleanup Old Resources
    runs-on: ubuntu-latest
    needs: [blue-green-deploy, switch-traffic]
    if: always() && needs.switch-traffic.result == 'success'
    
    steps:
      - name: 🔧 Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_DEFAULT_REGION }}

      - name: 🧹 Cleanup old blue stack
        run: |
          set -euo pipefail
          
          BLUE_STACK="subscriber-migration-portal-prod"
          
          # Wait 10 minutes before cleanup (for potential rollback)
          echo "⏳ Waiting 10 minutes before cleanup (rollback window)..."
          sleep 600
          
          # Check if there are old green stacks to clean up
          OLD_GREEN_STACKS=$(aws cloudformation list-stacks \
            --stack-status-filter CREATE_COMPLETE UPDATE_COMPLETE \
            --query "StackSummaries[?contains(StackName, 'subscriber-migration-portal-prod-green-') && StackName != '${GREEN_STACK}'].StackName" \
            --output text || echo "")
          
          if [[ -n "$OLD_GREEN_STACKS" ]]; then
            echo "🧹 Cleaning up old green stacks: $OLD_GREEN_STACKS"
            for stack in $OLD_GREEN_STACKS; do
              echo "🗑️ Deleting old stack: $stack"
              aws cloudformation delete-stack --stack-name "$stack" || true
            done
          else
            echo "ℹ️ No old green stacks to cleanup"
          fi
          
          echo "✅ Cleanup completed"

# ==========================================
# SECURITY AND PERMISSIONS
# ==========================================
permissions:
  contents: read
  id-token: write