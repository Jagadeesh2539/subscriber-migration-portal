name: Destroy - Full Teardown (Force)

on:
  workflow_dispatch:
    inputs:
      confirm:
        description: 'Type DESTROY to confirm full teardown'
        required: true
        default: ''
      region:
        description: 'AWS region'
        required: false
        default: '${{ vars.AWS_REGION || 'us-east-1' }}'

permissions:
  contents: read
  id-token: write

env:
  AWS_REGION: ${{ inputs.region || vars.AWS_REGION || 'us-east-1' }}

jobs:
  destroy:
    runs-on: ubuntu-latest
    environment: production
    steps:
      - name: Safety confirmation
        run: |
          if [ "${{ inputs.confirm }}" != "DESTROY" ]; then
            echo "Refusing to proceed without explicit confirmation. Type DESTROY."
            exit 1
          fi

      - uses: actions/checkout@v4

      - uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ vars.AWS_ROLE_ARN || '' }}
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Resolve resource names
        id: names
        run: |
          echo "SUB_TABLE=${{ vars.SUBSCRIBER_TABLE_NAME || 'subscriber-table' }}" >> $GITHUB_OUTPUT
          echo "MIG_TABLE=${{ vars.MIGRATION_JOBS_TABLE_NAME || 'migration-jobs-table' }}" >> $GITHUB_OUTPUT
          echo "AUD_TABLE=${{ vars.AUDIT_LOG_TABLE_NAME || 'audit-log-table' }}" >> $GITHUB_OUTPUT
          echo "FRONTEND_BUCKET=${{ vars.S3_FRONTEND_BUCKET || '' }}" >> $GITHUB_OUTPUT
          echo "UPLOAD_BUCKET=${{ vars.MIGRATION_UPLOAD_BUCKET_NAME || '' }}" >> $GITHUB_OUTPUT
          echo "STACK_NAME=${{ vars.CF_STACK_NAME || 'subscriber-migration-stack' }}" >> $GITHUB_OUTPUT
          echo "FUNCTION_NAME=${{ vars.LAMBDA_FUNCTION_NAME || secrets.LAMBDA_BACKEND_NAME || '' }}" >> $GITHUB_OUTPUT
          echo "API_ID=${{ vars.API_GATEWAY_ID || '' }}" >> $GITHUB_OUTPUT

      - name: Disable Lambda alias and delete function (best effort)
        run: |
          set -e
          FN="${{ steps.names.outputs.FUNCTION_NAME }}"
          if [ -n "$FN" ] && aws lambda get-function --function-name "$FN" >/dev/null 2>&1; then
            echo "Deleting Lambda aliases and function $FN"
            for ALIAS in $(aws lambda list-aliases --function-name "$FN" --query 'Aliases[].Name' --output text); do
              aws lambda delete-alias --function-name "$FN" --name "$ALIAS" || true
            done
            aws lambda delete-function --function-name "$FN" || true
          else
            echo "Lambda function not found or not set, skipping"
          fi

      - name: Delete API Gateway REST API (best effort)
        run: |
          set -e
          if [ -n "${{ steps.names.outputs.API_ID }}" ]; then
            if aws apigateway get-rest-api --rest-api-id "${{ steps.names.outputs.API_ID }}" >/dev/null 2>&1; then
              echo "Deleting API Gateway ${ { steps.names.outputs.API_ID } }"
              aws apigateway delete-rest-api --rest-api-id "${{ steps.names.outputs.API_ID }}" || true
            fi
          fi

      - name: Delete Step Functions and SQS (prefix: subscriber-migration)
        run: |
          set -e
          for ARN in $(aws stepfunctions list-state-machines --query "stateMachines[?starts_with(name, 'subscriber-migration')].stateMachineArn" --output text); do
            echo "Deleting state machine $ARN"
            aws stepfunctions delete-state-machine --state-machine-arn "$ARN" || true
          done
          for URL in $(aws sqs list-queues --queue-name-prefix "subscriber-migration" --query 'QueueUrls[]' --output text); do
            echo "Deleting SQS queue $URL"
            aws sqs delete-queue --queue-url "$URL" || true
          done

      - name: Delete DynamoDB tables
        run: |
          set -e
          for T in "${{ steps.names.outputs.SUB_TABLE }}" "${{ steps.names.outputs.MIG_TABLE }}" "${{ steps.names.outputs.AUD_TABLE }}"; do
            if [ -n "$T" ] && aws dynamodb describe-table --table-name "$T" >/dev/null 2>&1; then
              echo "Deleting DynamoDB table $T"
              aws dynamodb delete-table --table-name "$T"
              aws dynamodb wait table-not-exists --table-name "$T"
            fi
          done

      - name: Empty and delete S3 buckets
        run: |
          set -e
          for B in "${{ steps.names.outputs.FRONTEND_BUCKET }}" "${{ steps.names.outputs.UPLOAD_BUCKET }}"; do
            if [ -n "$B" ] && aws s3api head-bucket --bucket "$B" 2>/dev/null; then
              echo "Emptying bucket $B"
              aws s3 rm "s3://$B" --recursive || true
              echo "Deleting bucket $B"
              aws s3api delete-bucket --bucket "$B" || true
            fi
          done

      - name: Delete CloudFormation stack (last)
        run: |
          set -e
          STACK="${{ steps.names.outputs.STACK_NAME }}"
          if aws cloudformation describe-stacks --stack-name "$STACK" >/dev/null 2>&1; then
            echo "Deleting stack $STACK"
            aws cloudformation delete-stack --stack-name "$STACK"
            aws cloudformation wait stack-delete-complete --stack-name "$STACK" || true
          else
            echo "Stack $STACK not found"
          fi

      - name: Completed
        run: echo "Full destroy completed."