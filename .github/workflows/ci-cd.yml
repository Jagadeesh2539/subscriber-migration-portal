name: Deploy Subscriber Migration Portal

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]
  workflow_dispatch:
    inputs:
      stage:
        description: 'Deployment stage'
        required: true
        default: 'prod'
        type: choice
        options: [dev, test, prod]
      mode:
        description: 'Mode: deploy or dry-run'
        required: true
        default: 'deploy'
        type: choice
        options: [deploy, dry-run]

env:
  AWS_DEFAULT_REGION: us-west-2
  AWS_REGION: us-west-2
  STACK_NAME: subscriber-migration-portal-prod
  BUCKET_SUFFIX: '20251031'
  STAGE: prod
  WORKFLOW_SIGNATURE: 'ci-fix-yaml-no-heredoc-2025-10-31T17:20Z'
  EFFECTIVE_STAGE: ${{ inputs.stage || env.STAGE }}
  EFFECTIVE_MODE:  ${{ inputs.mode || 'deploy' }}

concurrency:
  group: deploy-${{ github.ref }}
  cancel-in-progress: true

jobs:
  build-test-deploy:
    name: CI/CD ‚Äì Subscriber Migration Portal
    runs-on: ubuntu-latest
    timeout-minutes: 90
    steps:
      - name: 00 Guard ‚Äì print workflow signature
        run: |
          echo "Using workflow signature: $WORKFLOW_SIGNATURE"
          echo "Ref: $GITHUB_REF / SHA: $GITHUB_SHA"
          echo "Actor: $GITHUB_ACTOR"

      - name: 01 Checkout repository
        uses: actions/checkout@v4

      - name: 02 Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'
          cache: 'pip'

      - name: 03 Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: 04 Preflight
        run: |
          echo "Stage: $EFFECTIVE_STAGE"
          echo "Mode:  $EFFECTIVE_MODE"
          if [ "$EFFECTIVE_MODE" = "dry-run" ]; then
            echo "Dry run selected; exiting before deploy."
            exit 0
          fi

      - name: 05 Setup SAM CLI
        uses: aws-actions/setup-sam@v2
        with:
          use-installer: true

      - name: 06 Install build dependencies
        run: |
          sudo apt-get update -y
          sudo apt-get install -y jq
          python -m pip install --upgrade pip
          pip install boto3 pymysql

      - name: 07 Build SAM application
        working-directory: aws
        run: |
          echo "===== BUILD START ====="
          sam build --use-container
          echo "===== BUILD END ====="

      - name: 08 Deploy with DB instance-class fallback (t3.micro ‚Üí t2.micro)
        id: deploy
        working-directory: aws
        env:
          DB_CLASSES: "db.t3.micro db.t2.micro"
        run: |
          set -euo pipefail
          echo "===== DEPLOY START ====="
          STACK="$STACK_NAME"
          if [ "$EFFECTIVE_STAGE" != "" ] && [ "$EFFECTIVE_STAGE" != "prod" ]; then
            STACK="subscriber-migration-portal-$EFFECTIVE_STAGE"
          fi
          for DBC in $DB_CLASSES; do
            echo "Attempting deploy with DbInstanceClass=$DBC in $AWS_REGION"
            if sam deploy \
              --stack-name "$STACK" \
              --region "$AWS_REGION" \
              --capabilities CAPABILITY_IAM CAPABILITY_NAMED_IAM \
              --no-confirm-changeset \
              --no-fail-on-empty-changeset \
              --parameter-overrides \
                Stage="$EFFECTIVE_STAGE" \
                JwtSecret="${{ secrets.JWT_SECRET }}" \
                CorsOrigins="${{ secrets.CORS_ORIGINS || 'https://yourdomain.com' }}" \
                BucketSuffix="$BUCKET_SUFFIX" \
                DbInstanceClass="$DBC"; then
              echo "db_class=$DBC" >> $GITHUB_OUTPUT
              echo "‚úÖ Deploy succeeded with $DBC"
              echo "===== DEPLOY END (SUCCESS) ====="
              exit 0
            else
              echo "‚ö†Ô∏è Deploy failed with $DBC, trying next..."
              if aws cloudformation describe-stacks --region "$AWS_REGION" --stack-name "$STACK" >/dev/null 2>&1; then
                STATUS=$(aws cloudformation describe-stacks --region "$AWS_REGION" --stack-name "$STACK" --query "Stacks[0].StackStatus" --output text || true)
                echo "Stack status: $STATUS"
                if [[ "$STATUS" == *"ROLLBACK"* || "$STATUS" == *"FAILED"* ]]; then
                  echo "üóëÔ∏è Deleting bad stack $STACK"
                  aws cloudformation delete-stack --region "$AWS_REGION" --stack-name "$STACK"
                  aws cloudformation wait stack-delete-complete --region "$AWS_REGION" --stack-name "$STACK" || true
                  UPB="${STACK}-uploads-${BUCKET_SUFFIX}"
                  echo "üßπ Force-empty S3 bucket: $UPB in $AWS_REGION"
                  while true; do
                    VERS=$(aws s3api list-object-versions --bucket "$UPB" --query '{Objects: Versions[].{Key:Key,VersionId:VersionId}}' --output json --region "$AWS_REGION" || echo '{"Objects":[]}')
                    COUNT=$(echo "$VERS" | jq '.Objects | length')
                    if [ "$COUNT" = "0" ]; then break; fi
                    echo "$VERS" > /tmp/vers.json
                    aws s3api delete-objects --bucket "$UPB" --delete file:///tmp/vers.json --region "$AWS_REGION" || true
                  done
                  while true; do
                    MKRS=$(aws s3api list-object-versions --bucket "$UPB" --query '{Objects: DeleteMarkers[].{Key:Key,VersionId:VersionId}}' --output json --region "$AWS_REGION" || echo '{"Objects":[]}')
                    COUNT2=$(echo "$MKRS" | jq '.Objects | length')
                    if [ "$COUNT2" = "0" ]; then break; fi
                    echo "$MKRS" > /tmp/mkrs.json
                    aws s3api delete-objects --bucket "$UPB" --delete file:///tmp/mkrs.json --region "$AWS_REGION" || true
                  done
                  aws s3api delete-bucket --bucket "$UPB" --region "$AWS_REGION" || true
                fi
              fi
            fi
          done
          echo "‚ùå All DB instance classes failed"
          echo "===== DEPLOY END (FAILED) ====="
          exit 1

      - name: 09 Export CloudFormation outputs
        if: steps.deploy.outcome == 'success'
        id: cfn-outputs
        run: |
          set -euo pipefail
          STACK="$STACK_NAME"
          if [ "$EFFECTIVE_STAGE" != "" ] && [ "$EFFECTIVE_STAGE" != "prod" ]; then
            STACK="subscriber-migration-portal-$EFFECTIVE_STAGE"
          fi
          OUT=$(aws cloudformation describe-stacks --region "$AWS_REGION" --stack-name "$STACK" --query "Stacks[0].Outputs" --output json)
          echo "CFN_OUTPUTS=$OUT" >> $GITHUB_ENV
          python - <<'PY'
import os, json
outs=json.loads(os.environ['CFN_OUTPUTS'])
m={o['OutputKey']:o['OutputValue'] for o in outs}
with open(os.environ['GITHUB_ENV'],'a') as f:
  for k in ['ApiEndpoint','LegacyDbSecretArn','LegacyDbHost','SchemaInitFunctionName','UploadsBucketName']:
    f.write(f"{k}={m.get(k,'')}\n")
print('‚úÖ Outputs exported')
PY

      - name: 10 Initialize MySQL schema (Lambda in VPC)
        if: steps.deploy.outcome == 'success'
        run: |
          set -euo pipefail
          echo "===== SCHEMA INIT (LAMBDA) START ====="
          aws lambda invoke \
            --region "$AWS_REGION" \
            --function-name "$SCHEMA_INIT_FUNCTION_NAME" \
            --payload '{}' \
            --log-type Tail \
            --query 'LogResult' \
            --output text \
            out.json | base64 -d || true
          echo
          cat out.json || true
          echo
          OK=$(jq -r '.success // false' out.json 2>/dev/null || echo false)
          if [ "$OK" != "true" ]; then
            echo "‚ùó Lambda schema init reported errors; running direct fallback"
          else
            echo "‚úÖ Lambda schema initialization completed"
            echo "===== SCHEMA INIT (LAMBDA) END (SUCCESS) ====="
            exit 0
          fi

      - name: 11 Initialize MySQL schema (Direct runner fallback)
        if: steps.deploy.outcome == 'success'
        env:
          AWS_REGION: ${{ env.AWS_REGION }}
          LEGACY_DB_SECRET_ARN: ${{ env.LegacyDbSecretArn }}
          LEGACY_DB_HOST: ${{ env.LegacyDbHost }}
        run: |
          set -euo pipefail
          echo "===== SCHEMA INIT (DIRECT) START ====="
          python - <<'PY'
import os, json, boto3, pymysql, sys
region = os.environ.get('AWS_REGION','us-west-2')
secret_arn = os.environ.get('LEGACY_DB_SECRET_ARN','')
host = os.environ.get('LEGACY_DB_HOST','')
sql_file = 'database/rds_schema_update.sql'
if not secret_arn or not host:
    print('‚ùå Missing LegacyDbSecretArn/LegacyDbHost from outputs', file=sys.stderr)
    sys.exit(1)
if not os.path.exists(sql_file):
    print('‚ùå No schema file found', file=sys.stderr)
    sys.exit(1)
sm = boto3.client('secretsmanager', region_name=region)
sec = json.loads(sm.get_secret_value(SecretId=secret_arn)['SecretString'])
user = sec.get('username') or sec.get('user')
pwd  = sec.get('password') or sec.get('pass')
db   = sec.get('dbname') or sec.get('database') or ''
if not (user and pwd):
    print('‚ùå Secret missing username/password', file=sys.stderr)
    sys.exit(1)
conn = pymysql.connect(host=host, user=user, password=pwd, database=db, autocommit=True, connect_timeout=30, charset='utf8mb4')
executed = skipped = errors = 0
with conn.cursor() as cur, open(sql_file, 'r', encoding='utf-8') as f:
    sql = f.read()
    stmts = [s.strip() for s in sql.split(';') if s.strip() and not s.strip().startswith('--')]
    for stmt in stmts:
        try:
            cur.execute(stmt)
            executed += 1
            print(f'Executed: {stmt[:80]}...')
        except Exception as e:
            msg = str(e).lower()
            if 'already exists' in msg or 'duplicate' in msg or 'exists' in msg:
                skipped += 1
                print(f'Skip exists: {stmt[:80]}...')
            else:
                errors += 1
                print(f'Error executing {stmt[:80]}...: {e}', file=sys.stderr)
print(f'‚úÖ Schema init completed: executed={executed}, skipped={skipped}, errors={errors}')
if errors:
    sys.exit(1)
PY
          echo "===== SCHEMA INIT (DIRECT) END ====="

      - name: 12 Notify failure
        if: failure()
        run: |
          echo "‚ùå Deploy failed for $GITHUB_REF"
          echo "Check logs for steps 08-11 for details."
