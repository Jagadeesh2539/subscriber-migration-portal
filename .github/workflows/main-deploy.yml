name: Deploy Subscriber Migration Portal

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]
  workflow_dispatch:
    inputs:
      force_recreate:
        description: 'Force recreate stack (true/false)'
        type: boolean
        default: false
      cleanup_resources:
        description: 'Cleanup failed/orphaned resources (true/false)'
        type: boolean
        default: false
      environment:
        description: 'Target Environment'
        type: choice
        options: [dev, stage, prod]
        default: 'dev'

permissions:
  contents: read
  id-token: write

env:
  AWS_REGION: ${{ vars.AWS_REGION || 'us-east-1' }}
  CF_STACK_NAME: ${{ vars.CF_STACK_NAME || 'subscriber-migration-stack' }}

jobs:
  lint-format-check:
    name: Lint & Format Check (Backend)
    if: github.event_name == 'pull_request' || github.ref == 'refs/heads/main'
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-python@v5
        with:
          python-version: '3.11'
      - name: Install Tools
        run: pip install black isort flake8
      - name: Run Formatters & Linters (Check Only)
        working-directory: backend
        run: |
          isort --check-only --diff .
          black --check --diff .
          flake8 --max-line-length 120 --extend-ignore E203,W503 .

  prepare-infra:
    name: Prepare Infrastructure (Cleanup/Failed states)
    needs: [lint-format-check]
    if: github.event_name == 'push' && github.ref == 'refs/heads/main' || github.event_name == 'workflow_dispatch'
    runs-on: ubuntu-latest
    environment: ${{ github.event.inputs.environment || 'dev' }}
    env:
      FORCE_RECREATE: ${{ github.event.inputs.force_recreate || vars.FORCE_RECREATE || 'false' }}
      CLEANUP_RESOURCES: ${{ github.event.inputs.cleanup_resources || vars.CLEANUP_FAILED || 'false' }}
    steps:
      - uses: actions/checkout@v4
      - uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ vars.AWS_ROLE_ARN || '' }}
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}
      - name: Resolve resource names
        id: names
        run: |
          echo "SUB_TABLE=${{ vars.SUBSCRIBER_TABLE_NAME || 'subscriber-table' }}" >> $GITHUB_OUTPUT
          echo "MIG_TABLE=${{ vars.MIGRATION_JOBS_TABLE_NAME || 'migration-jobs-table' }}" >> $GITHUB_OUTPUT
          echo "AUD_TABLE=${{ vars.AUDIT_LOG_TABLE_NAME || 'audit-log-table' }}" >> $GITHUB_OUTPUT
          echo "FRONTEND_BUCKET=${{ vars.S3_FRONTEND_BUCKET || '' }}" >> $GITHUB_OUTPUT
          echo "UPLOAD_BUCKET=${{ vars.MIGRATION_UPLOAD_BUCKET_NAME || '' }}" >> $GITHUB_OUTPUT
      - name: Detect Stack Status & Cleanup/Prepare
        run: |
          set -e
          STACK="${{ env.CF_STACK_NAME }}"
          STATUS=$(aws cloudformation describe-stacks --stack-name "$STACK" --query 'Stacks[0].StackStatus' --output text 2>/dev/null || echo 'NONE')
          echo "Stack: $STACK Status: $STATUS"
          if [ "$CLEANUP_RESOURCES" = "true" ]; then
            case "$STATUS" in
              DELETE_FAILED|ROLLBACK_COMPLETE|ROLLBACK_FAILED|CREATE_FAILED|UPDATE_ROLLBACK_COMPLETE|UPDATE_ROLLBACK_FAILED)
                echo "Deleting failed/rollback stack $STACK"
                aws cloudformation delete-stack --stack-name "$STACK" || true
                aws cloudformation wait stack-delete-complete --stack-name "$STACK" || true
                ;;
              *) echo "No failed stack deletion required";;
            esac
            # Orphan cleanup
            for T in "${{ steps.names.outputs.SUB_TABLE }}" "${{ steps.names.outputs.MIG_TABLE }}" "${{ steps.names.outputs.AUD_TABLE }}"; do
              if [ -n "$T" ] && aws dynamodb describe-table --table-name "$T" >/dev/null 2>&1; then
                echo "Deleting DynamoDB table $T"; aws dynamodb delete-table --table-name "$T"; aws dynamodb wait table-not-exists --table-name "$T"; fi; done
            for B in "${{ steps.names.outputs.FRONTEND_BUCKET }}" "${{ steps.names.outputs.UPLOAD_BUCKET }}"; do
              if [ -n "$B" ] && aws s3api head-bucket --bucket "$B" 2>/dev/null; then
                echo "Empty+delete S3 bucket $B"; aws s3 rm "s3://$B" --recursive || true; aws s3api delete-bucket --bucket "$B" || true; fi; done
            for ARN in $(aws stepfunctions list-state-machines --query "stateMachines[?starts_with(name, 'subscriber-migration')].stateMachineArn" --output text); do
              echo "Delete SFN $ARN"; aws stepfunctions delete-state-machine --state-machine-arn "$ARN" || true; done
            for URL in $(aws sqs list-queues --queue-name-prefix "subscriber-migration" --query 'QueueUrls[]' --output text); do
              echo "Delete SQS $URL"; aws sqs delete-queue --queue-url "$URL" || true; done
          fi
          if [ "$FORCE_RECREATE" = "true" ]; then
            echo "Force re-create $STACK";
            if aws cloudformation describe-stacks --stack-name "$STACK" >/dev/null 2>&1; then
              aws cloudformation delete-stack --stack-name "$STACK"; aws cloudformation wait stack-delete-complete --stack-name "$STACK" || true; fi
          fi

  deploy-infra:
    name: Deploy Infrastructure (CloudFormation)
    needs: prepare-infra
    if: github.event_name == 'push' && github.ref == 'refs/heads/main' || github.event_name == 'workflow_dispatch'
    runs-on: ubuntu-latest
    environment: ${{ github.event.inputs.environment || 'dev' }}
    outputs:
      backend_lambda_name: ${{ steps.extract.outputs.backend_lambda_name }}
      migration_lambda_name: ${{ steps.extract.outputs.migration_lambda_name }}
      frontend_bucket: ${{ steps.extract.outputs.frontend_bucket }}
      backend_api_url: ${{ steps.extract.outputs.backend_api_url }}
    steps:
      - uses: actions/checkout@v4
      - uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ vars.AWS_ROLE_ARN || '' }}
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}
      - name: Deploy CloudFormation stack (if template exists)
        run: |
          if [ -f infrastructure/cloudformation/stack.yaml ]; then
            aws cloudformation deploy \
              --template-file infrastructure/cloudformation/stack.yaml \
              --stack-name "${{ env.CF_STACK_NAME }}" \
              --capabilities CAPABILITY_NAMED_IAM \
              --parameter-overrides \
                SubscriberTableName=${{ vars.SUBSCRIBER_TABLE_NAME || 'subscriber-table' }} \
                MigrationJobsTableName=${{ vars.MIGRATION_JOBS_TABLE_NAME || 'migration-jobs-table' }} \
                AuditLogTableName=${{ vars.AUDIT_LOG_TABLE_NAME || 'audit-log-table' }} \
                FrontendBucket=${{ vars.S3_FRONTEND_BUCKET || 'subscriber-migration-frontend' }} || true
          else
            echo "No CloudFormation template found, skipping"
          fi
      - name: Extract stack outputs
        id: extract
        run: |
          set -e
          STACK="${{ env.CF_STACK_NAME }}"
          BK=$(aws cloudformation describe-stacks --stack-name "$STACK" --query 'Stacks[0].Outputs[?OutputKey==`BackendLambdaName`].OutputValue' --output text 2>/dev/null || echo '${{ vars.LAMBDA_FUNCTION_NAME || '' }}')
          MP=$(aws cloudformation describe-stacks --stack-name "$STACK" --query 'Stacks[0].Outputs[?OutputKey==`MigrationLambdaName`].OutputValue' --output text 2>/dev/null || echo '')
          FB=$(aws cloudformation describe-stacks --stack-name "$STACK" --query 'Stacks[0].Outputs[?OutputKey==`FrontendBucket`].OutputValue' --output text 2>/dev/null || echo '${{ vars.S3_FRONTEND_BUCKET || '' }}')
          API=$(aws cloudformation describe-stacks --stack-name "$STACK" --query 'Stacks[0].Outputs[?OutputKey==`ApiBaseUrl`].OutputValue' --output text 2>/dev/null || echo "https://${{ vars.API_GATEWAY_ID }}.execute-api.${{ env.AWS_REGION }}.amazonaws.com/prod")
          echo "backend_lambda_name=$BK" >> $GITHUB_OUTPUT
          echo "migration_lambda_name=$MP" >> $GITHUB_OUTPUT
          echo "frontend_bucket=$FB" >> $GITHUB_OUTPUT
          echo "backend_api_url=$API" >> $GITHUB_OUTPUT

  deploy-backend:
    name: Build & Deploy Backend
    needs: deploy-infra
    if: github.event_name == 'push' && github.ref == 'refs/heads/main' || github.event_name == 'workflow_dispatch'
    runs-on: ubuntu-latest
    environment: ${{ github.event.inputs.environment || 'dev' }}
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-python@v5
        with:
          python-version: '3.11'
      - uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ vars.AWS_ROLE_ARN || '' }}
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}
      - name: Package Backend
        working-directory: backend
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt -t package/
          cp app.py package/
          if [ -d src ]; then cp -R src package/src; fi
          cd package && zip -r ../lambda-deployment-package.zip .
      - name: Deploy Backend Lambda Code
        run: |
          aws lambda update-function-code --function-name "${{ needs.deploy-infra.outputs.backend_lambda_name }}" --zip-file fileb://backend/lambda-deployment-package.zip
          aws lambda wait function-updated --function-name "${{ needs.deploy-infra.outputs.backend_lambda_name }}"

  deploy-frontend:
    name: Build & Deploy Frontend
    needs: deploy-infra
    if: github.event_name == 'push' && github.ref == 'refs/heads/main' || github.event_name == 'workflow_dispatch'
    runs-on: ubuntu-latest
    environment: ${{ github.event.inputs.environment || 'dev' }}
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: 20
      - uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ vars.AWS_ROLE_ARN || '' }}
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}
      - name: Build Frontend
        working-directory: frontend
        env:
          REACT_APP_API_BASE_URL: ${{ needs.deploy-infra.outputs.backend_api_url }}
          REACT_APP_LEGACY_ENABLED: 'true'
          REACT_APP_MIGRATION_ENABLED: 'true'
        run: |
          npm ci || npm install
          npm run build
      - name: Deploy Frontend to S3
        run: |
          aws s3 sync frontend/build "s3://${{ needs.deploy-infra.outputs.frontend_bucket }}" --delete --cache-control "public,max-age=300"
      - name: Invalidate CloudFront Cache (Optional)
        if: ${{ vars.CLOUDFRONT_DISTRIBUTION_ID != '' }}
        run: |
          aws cloudfront create-invalidation --distribution-id "${{ vars.CLOUDFRONT_DISTRIBUTION_ID }}" --paths "/*"

  smoke-tests:
    name: Post-Deployment Smoke Tests
    needs: [deploy-backend, deploy-frontend]
    if: github.event_name == 'push' && github.ref == 'refs/heads/main' || github.event_name == 'workflow_dispatch'
    runs-on: ubuntu-latest
    steps:
      - name: API Health
        run: |
          curl -fsS ${{ needs.deploy-infra.outputs.backend_api_url }}/api/health
      - name: Auth Smoke
        run: |
          TOKEN=$(curl -fsS -X POST "${{ needs.deploy-infra.outputs.backend_api_url }}/api/auth/login" -H "Content-Type: application/json" -d '{"username":"admin","password":"Admin@123"}' | jq -r '.token')
          test -n "$TOKEN"
      - name: Subscribers Stats
        run: |
          curl -fsS "${{ needs.deploy-infra.outputs.backend_api_url }}/api/subscribers/stats" -H "Authorization: Bearer $TOKEN"